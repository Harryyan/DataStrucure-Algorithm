# 分治

将问题切割，当切割后问题足够小的时候，直接解决(conquer)它; 最后，将小问题的解合并起来，就得到原始问题的解.

## 快速幂 (Leetcode-50)
该题使用分治，可以使得时间复杂度变为O(logN). 分治实现可以是迭代，也可以是递归. 核心在于分开奇偶，对于偶数, x^n = x^n/2 * x^n/2; 对于奇数，x^n = x^(n+1)/2 * x^(n-1)/2:

```swift
class Solution {
    // tc: O(logn)
    // sc: O(1)
    func myPow(_ x: Double, _ n: Int) -> Double {
        guard n != 0 else { return 1.0 }

        if n > 0 {
            return quickMul(x,n)
        } else {
            return 1 / quickMul(x,-n)
        }
    }

    private func quickMul(_ x: Double, _ n: Int) -> Double {
        var ans = 1.0
        var x = x
        var n = n

        while n > 0 {
            if n % 2 == 1 {
                ans *= x
            }

            x *= x
            n /= 2
        }

        return ans
    }
}
```

## 数组中的第K个最大元素 (Leetcode-215)
快排变种，也可以用优先队列来解(TopK 问题).

```swift
class Solution {
    var res = -1

    func findKthLargest(_ nums: [Int], _ k: Int) -> Int {
        quickSort(start: 0, end: nums.count-1, nums: nums, k: k)

        return res
    }

    // tc: O(n) -> 算法导论9.2证明
    // sc: O(logn)
    private func quickSort(start: Int, end: Int, nums: [Int], k: Int) {
        guard res == -1, start <= end else { return }

        var pivot = nums[start]
        var low = start
        var high = end
        var nums = nums

        while low < high {
            while low < high && nums[high] >= pivot {
                high -= 1
            }

            nums[low] = nums[high]

            while low < high && nums[low] <= pivot {
                low += 1
            }

            nums[high] = nums[low]
        }

        nums[low] = pivot

        let n = nums.count

        if low == n - k {
            res = pivot
        } else if low > n - k {
            quickSort(start: start, end: low-1, nums: nums, k:k)
        } else {
            quickSort(start: low+1, end: end, nums:nums, k: k)
        }
    }
}
```
