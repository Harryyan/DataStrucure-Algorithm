# 滑动窗口 / 双指针

## 滑动窗口

滑动窗口一般用来解决有连续子区间的问题, 避免暴力两层循环，减少时间复杂度。

### 无重复字符的最长子串 (Leetcode-3)

典型滑动窗口，首先从头找到最长无重复子串，放入一个数组里；之后将头部pop，将新元素append进去。

```swift
class Solution {
    func lengthOfLongestSubstring(_ s: String) -> Int {
        var maxCount = 0
        var array = [Character]()

        for char in s {
            if let index = array.firstIndex(of: char) {
                array.removeFirst(index + 1)
            }

            array.append(char)

            if(array.count > maxCount){
                maxCount = array.count
            }
        }
        
        return maxCount
    }
}
```

### 最小覆盖子串 (leetcode-76)

也是典型滑动窗口题目，不过难点在于如何高效的持续判断另一个字串在当前区间内。我们需要一个欢动窗口字典来辅助：

```swift
class Solution {
    func minWindow(_ s: String, _ t: String) -> String {
        let sArr = [Character](s)
        let tArr = [Character](t)
        if sArr.count < tArr.count { return "" }
        var needs = [Character: Int]()
        var window = [Character: Int]()
        for c in tArr {
            needs[c] = needs[c] == nil ? 1 : needs[c]! + 1
        }
        var left = 0, right = 0, match = 0
        var start = 0
        var length = Int.max

        while right < sArr.count {
            let c = sArr[right]
            window[c] = window[c] == nil ? 1 : window[c]! + 1
            if window[c] == needs[c] {
                match += 1
            }
            
            while match == needs.count {
                if right - left + 1 < length {
                    start = left
                    length = right - left + 1
                }
                let c = sArr[left]
                if nil != window[c] {
                    window[c]! -= 1
                    if let need = needs[c], window[c]! < need {
                        match -= 1
                    }
                }
                left += 1
            }
            right += 1
        }
        return length == Int.max ? "" : String(sArr[start...start + length - 1])
    }
}
```