# 滑动窗口 / 双指针

滑动窗口是双指针的其中一种，它使用两个(或以上)移动方向相同的指针在可遍历对象（例如数组或字符串）中寻找最长（最短）的合法子区间。

## 滑动窗口

滑动窗口一般用来解决有连续子区间的问题, 避免暴力两层循环，减少时间复杂度。

### 无重复字符的最长子串 (Leetcode-3)

典型滑动窗口，首先从头找到最长无重复子串，放入一个数组里；之后将头部pop，将新元素append进去。

```swift
class Solution {
    func lengthOfLongestSubstring(_ s: String) -> Int {
        var maxCount = 0
        var array = [Character]()

        for char in s {
            if let index = array.firstIndex(of: char) {
                array.removeFirst(index + 1)
            }

            array.append(char)

            if(array.count > maxCount){
                maxCount = array.count
            }
        }
        
        return maxCount
    }
}
```

### 最小覆盖子串 (leetcode-76)

也是典型滑动窗口题目，不过难点在于如何高效的持续判断另一个字串在当前区间内。我们需要一个欢动窗口字典来辅助：

```swift
class Solution {
    func minWindow(_ s: String, _ t: String) -> String {
        let sArr = [Character](s)
        let tArr = [Character](t)
        if sArr.count < tArr.count { return "" }
        var needs = [Character: Int]()
        var window = [Character: Int]()
        for c in tArr {
            needs[c] = needs[c] == nil ? 1 : needs[c]! + 1
        }
        var left = 0, right = 0, match = 0
        var start = 0
        var length = Int.max

        while right < sArr.count {
            let c = sArr[right]
            window[c] = window[c] == nil ? 1 : window[c]! + 1
            if window[c] == needs[c] {
                match += 1
            }
            
            while match == needs.count {
                if right - left + 1 < length {
                    start = left
                    length = right - left + 1
                }
                let c = sArr[left]
                if nil != window[c] {
                    window[c]! -= 1
                    if let need = needs[c], window[c]! < need {
                        match -= 1
                    }
                }
                left += 1
            }
            right += 1
        }
        return length == Int.max ? "" : String(sArr[start...start + length - 1])
    }
}
```

### 可获得的最大点数 (leetcode-1423)

这题类似石子题，都是只能从头尾选取，多了一个最多选取次数的阈值; 滑动窗口大小是 **数组长度 - k**

```swift
class Solution {
    func maxScore(_ cardPoints: [Int], _ k: Int) -> Int {
        guard k < cardPoints.count else {
            return cardPoints.reduce(.zero, +)
        }

        let slideWindowSize = cardPoints.count - k
        var res = Int.min
        var preSums = Array(repeating: 0, count: cardPoints.count)
        let end = cardPoints.count - 1

        preSums[0] = cardPoints[0]

        for i in 1...end{
            preSums[i] = preSums[i-1] + cardPoints[i]
        }

        let left = 0
        let right = left + slideWindowSize - 1
        res = preSums[end] - preSums[right]

        for i in 1...end {
            let right = i + slideWindowSize - 1

            if right > end {
                break
            }

            let first = preSums[i-1]
            let second = preSums[end] - preSums[right]

            res = max(res, first + second)
        }

        return res
    }
}
```

### 盛最多水的容器 (leetcode-11)
典型双指针, 从头尾分别开始，移动小的那个; 类似问题：有序数组平方(leetcode-977)

```swift
func maxArea(_ height: [Int]) -> Int {
    var left = 0
    var right = height.count - 1
    var result = 0

    while left < right {
        var lowerHeight = 0
        let distance = right - left

        if height[left] > height[right] {
            lowerHeight = height[right]
            right -= 1
        } else {
            lowerHeight = height[left]
            left += 1
        }

        result = max(distance * lowerHeight, result)
    }

    return result
}
```

### 找到字符串中所有字母异位词(leetcode-438)
该题属于固定滑窗，难点在于如何高效判断异位: 可以维护两个频次数组, 数组下标是0-25(a-z转化); 每次减少和添加一个字符，比对频次数组是否相同，相同则往结果数组里添加该index.

```swift
func findAnagrams(_ s: String, _ p: String) -> [Int] {
    var res: [Int] = []
    
    guard p.count <= s.count else { return res }
    
    let sLen = s.count
    let pLen = p.count
    let sList = Array(s)
    let pList = Array(p)
    
    // 频次数组
    var sCnt: [Int] = Array(repeating: 0, count: 26)
    var pCnt: [Int] = Array(repeating: 0, count: 26)
    
    for i in 0..<pLen {
        sCnt[index(of: sList[i])] += 1
        pCnt[index(of: pList[i])] += 1
    }

    if sCnt == pCnt {
        res.append(0)
    }
    
    guard pLen < sLen else { return res }
    
    for i in pLen..<sLen {
        let preCh = sList[i - pLen]
        let currentCh = sList[i]
        
        sCnt[index(of: preCh)] -= 1
        sCnt[index(of: currentCh)] += 1
        
        if sCnt == pCnt {
            res.append(i - pLen + 1)
        }
    }
    
    return res
}
    
private func index(of ch: Character) -> Int {
    return Int(ch.asciiValue!) - Int(Character("a").asciiValue!)
}
```

### 最长重复子数组(leetcode-718)
这题用DP很容易理解，这里提供一个双指针做法，类似两把尺子，交错着比对：

![](https://res.cloudinary.com/dwpjzbyux/image/upload/v1650169967/algorithm/slidewindow/slide_bfnzwy.gif)

```swift
class Solution {
    func findLength(_ A: [Int], _ B: [Int]) -> Int {
        if A.count < B.count {
            return _findLength(A,B)
        } else {
            return _findLength(B,A)
        }
    }

    func _findLength(_ A: [Int], _ B: [Int]) -> Int {
        let alen = A.count
        let blen = B.count
        let totalRunTimes = alen + blen - 1
        
        var res = 0
        
        for i in 0..<totalRunTimes {
            var aStart = 0
            var bStart = 0
            var len = 0
            
            if i < alen {
                aStart = alen - i - 1
                bStart = 0
                len = i + 1
            } else {
                aStart = 0
                bStart = i - alen + 1
                len = min(blen - bStart, alen)
            }
            
            //计算A和B在重叠区域最长子数组
            let middleResult = maxlen(A, B, aStart, bStart, len)
            res = max(res, middleResult)
        }
        
        return res
    }
    
    private func maxlen(_ A: [Int], _ B: [Int], _ aStart: Int, _ bStart: Int, _ len: Int) -> Int {
        var res = 0
        var count = 0
        
        for i in 0..<len {
            if A[aStart+i] == B[bStart+i] {
                count += 1
                res = max(res, count)
            } else {
                count = 0
            }
        }
        
        return res
    }
}
```
