# 股票/打家劫舍

[股票问题系列通解](https://leetcode-cn.com/circle/article/qiAgHn/)
关键是分析清楚状态，第几天，交易几次以及手里股票个数(0 or 1)

## 买卖股票的最佳时机 III(Leetcode-123)

```swift
func maxProfit(_ prices: [Int]) -> Int {
    guard prices.count > 0 else { return 0}

    var p10 = 0
    var p11 = -prices[0]
    var p20 = 0
    var p21 = -prices[0]

    for i in 0..<prices.count {
        p20 = max(p20, p21+prices[i])
        p21 = max(p21, p10-prices[i])
        p10 = max(p10, p11+prices[i])
        p11 = max(p11, -prices[i])
    }

    return p20
}
```

## 打家劫舍III (Leetcode-337)
无论何种形态的打家劫舍，都是选与不选的抉择:

```swift
func rob(_ root: TreeNode?) -> Int {
    let result = dfs(root)

    return max(result[0], result[1])
}

private func dfs(_ node: TreeNode?) -> [Int] {
    guard let node = node else { return [0,0] }

    let left = dfs(node.left)
    let right = dfs(node.right)

    let val1 = max(left[1],left[0]) + max(right[0],right[1])    // not rob current node
    let val2 = node.val + left[0] + right[0]                    // rob current node

    return [val1, val2]
}
```

## 删除并获得点数(Leetcode-740)
打家劫舍变体，需要有间隔的选择:

```swift
func deleteAndEarn(_ nums: [Int]) -> Int {
    if nums.count == 1 { return nums[0] }
    
    let maxNumber = nums.max() ?? 1
    var counts: [Int] = Array(repeating: 0, count: maxNumber+1)
    
    // 构建出现次数数组，下标是nums[i]
    for num in nums {
        counts[num] += 1
    }
    
    var dp = Array(repeating: 0, count: counts.count)
    dp[1] = counts[1]
    
    for i in 2..<counts.count {
        dp[i] = max(dp[i-1], dp[i-2]+i*counts[i])
    }

    return dp.last!
}
```