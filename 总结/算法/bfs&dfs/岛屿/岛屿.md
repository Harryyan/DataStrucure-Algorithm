# 岛屿数量

## 岛屿数量（Leetcode-200）
模板题，可使用dfs和并查集做：

```swift
class Solution {
    var grid: [[Character]] = []

    func numIslands(_ grid: [[Character]]) -> Int {
        guard grid.count > 0 else { return 0 }
        
        var res = 0
        self.grid = grid
        
        for i in 0..<self.grid.count {
            for j in 0..<self.grid[0].count {
                if String(self.grid[i][j]) == "1" {
                    dfs(i,j)
                    
                    res += 1
                }
            }
        }
        
        return res
    }
    
    private func dfs(_ x: Int, _ y: Int) {
        let directions = [[0,1], [0,-1], [1,0], [-1,0]]
        
        grid[x][y] = Character("0")
        
        for direction in directions {
            let newX = x + direction[0]
            let newY = y + direction[1]
            
            if newX >= 0 && newX < grid.count && newY >= 0 && newY < grid[0].count && String(self.grid[newX][newY]) == "1" {
                dfs(newX, newY)
            }
        }
    }
}
```

## 不同岛屿数量（Leetcode-694）
该题难点在于如何判定形状一致。可以将每个岛的每个像素点和起始点作差，若差一致，则形状一致。最后加入集合中，自动去重。

```swift
class Solution {
    let directions = [[0,1], [0,-1], [1,0], [-1,0]]
    var grids: [[Int]] = []
    var set = Set<[Int]>()

    func numDistinctIslands(_ grid: [[Int]]) -> Int {
        grids = grid
        var results = Set<Set<[Int]>>()

        for i in 0..<grids.count {
            for j in 0..<grids[0].count {
                if grids[i][j] == 1 {
                    dfs(i,j,i,j)
                    
                    // 去重
                    results.insert(set)

                    set = Set<[Int]>()
                }
            }
        }

        return results.count
    }

    private func dfs(_ x: Int, _ y: Int, _ originX: Int, _ originY: Int) {
        grids[x][y] = 0

		 // 每个岛与起始点做差，偏移一致，则为同样形状
        set.insert([x-originX, y-originY])

        for direction in directions {
            let newX = x + direction[0]
            let newY = y + direction[1]

            if newX >= 0 && newX < grids.count && newY >= 0 && newY < grids[0].count && grids[newX][newY] == 1 {
                dfs(newX,newY, originX, originY)
            }
        }
    }
}
```




# 岛屿变化

## 岛屿数量II（Leetcode-305）
该题总体思路是： 使用并查集不断更新数量; 需要注意的是position去重和坐标合并顺序：

```swift
class Solution {
    func numIslands2(_ m: Int, _ n: Int, _ positions: [[Int]]) -> [Int] {
        var grid: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: m)
        let dsu = DSU(m * n)
        let directions = [[0,1], [0,-1], [1,0], [-1,0]]
        var res = [Int]()
        var count = 0
        var set = Set<[Int]>()
        
        for position in positions {
            let x = position[0]
            let y = position[1]
            
            // 去重
            if !set.contains(position) {
                set.insert(position)
                count += 1
            } else {
                res.append(count)
                continue
            }
            
            grid[x][y] = 1

            var parents = Set<Int>()
            
            for direction in directions {
                let newX = x + direction[0]
                let newY = y + direction[1]
                
                // check 4 directions if any 1 can be connected
                if newX < m && newY < n && newY >= 0 && newX >= 0 && grid[newX][newY] == 1 {
                    let index1 = x * n + y
                    let index2 = newX * n + newY

                    let pId = dsu.find(index2)
                    parents.insert(pId)
			
			  // 注意参数顺序 
                    dsu.union(index2, index1)
                }
            }
            
            // 这里是减去周围不同父节点个数，而不是值为1的个数
            count -= parents.count
            
            res.append(count)
        }
        
        return res
    }
}

final class DSU {
    var parents: [Int] = []
    var count = 0

    init(_ n: Int) {
        parents = Array(repeating: 0, count: n)
        count = n

        for i in 0..<n {
            parents[i] = i
        }
    }

    func union(_ x: Int, _ y: Int) {
        let rootX = find(x)
        let rootY = find(y)

        guard rootX != rootY else { return }

        parents[rootY] = rootX
        count -= 1
    }

    func find(_ x: Int) -> Int {
        guard x != parents[x] else { return x }

        var current = x

        while current != parents[current] {
            current = parents[current]
        }

        return current
    }
}
```



# 岛屿边缘


