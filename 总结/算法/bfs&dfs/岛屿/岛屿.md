# 岛屿数量

## 岛屿数量（Leetcode-200）
模板题，可使用dfs和并查集做：

```swift
class Solution {
    var grid: [[Character]] = []

    func numIslands(_ grid: [[Character]]) -> Int {
        guard grid.count > 0 else { return 0 }
        
        var res = 0
        self.grid = grid
        
        for i in 0..<self.grid.count {
            for j in 0..<self.grid[0].count {
                if String(self.grid[i][j]) == "1" {
                    dfs(i,j)
                    
                    res += 1
                }
            }
        }
        
        return res
    }
    
    private func dfs(_ x: Int, _ y: Int) {
        let directions = [[0,1], [0,-1], [1,0], [-1,0]]
        
        grid[x][y] = Character("0")
        
        for direction in directions {
            let newX = x + direction[0]
            let newY = y + direction[1]
            
            if newX >= 0 && newX < grid.count && newY >= 0 && newY < grid[0].count && String(self.grid[newX][newY]) == "1" {
                dfs(newX, newY)
            }
        }
    }
}
```

## 不同岛屿数量（Leetcode-694）
该题难点在于如何判定形状一致。可以将每个岛的每个像素点和起始点作差，若差一致，则形状一致。最后加入集合中，自动去重。

```swift
class Solution {
    let directions = [[0,1], [0,-1], [1,0], [-1,0]]
    var grids: [[Int]] = []
    var set = Set<[Int]>()

    func numDistinctIslands(_ grid: [[Int]]) -> Int {
        grids = grid
        var results = Set<Set<[Int]>>()

        for i in 0..<grids.count {
            for j in 0..<grids[0].count {
                if grids[i][j] == 1 {
                    dfs(i,j,i,j)
                    
                    // 去重
                    results.insert(set)

                    set = Set<[Int]>()
                }
            }
        }

        return results.count
    }

    private func dfs(_ x: Int, _ y: Int, _ originX: Int, _ originY: Int) {
        grids[x][y] = 0

		 // 每个岛与起始点做差，偏移一致，则为同样形状
        set.insert([x-originX, y-originY])

        for direction in directions {
            let newX = x + direction[0]
            let newY = y + direction[1]

            if newX >= 0 && newX < grids.count && newY >= 0 && newY < grids[0].count && grids[newX][newY] == 1 {
                dfs(newX,newY, originX, originY)
            }
        }
    }
}
```

## 不同岛屿数量II（Leetcode-711）
这道题是694进阶版，关键在于如何将八个方向规规范化哈希。不同于694，这题需要将每个岛屿每个点之间进行欧几里得距离计算，然后求和，加入集合。这里不同语言有精度问题，例如以下Swift代码，有些test case不稳定。

```swift
class Solution {
    var visited = Set<[Int]>()
    var res = Set<Double>()
    var grids: [[Int]] = []
    let directions = [[0,1],[0,-1], [-1,0], [1,0]]

    func numDistinctIslands2(_ grid: [[Int]]) -> Int {
        grids = grid

        for i in 0..<grids.count {
            for j in 0..<grids[0].count {
                if grids[i][j] == 1 {
                    dfs(i,j)
                    hash()

                    visited = Set<[Int]>()
                }
            }
        }

        return res.count
    }

    private func dfs(_ x: Int, _ y: Int) {
        grids[x][y] = 0
        visited.insert([x,y])

        for direction in directions {
            let newX = x + direction[0]
            let newY = y + direction[1]

            if newX >= 0 && newX < grids.count && newY >= 0 && newY < grids[0].count && grids[newX][newY] == 1 {
                dfs(newX, newY)
            }
        }
    }

    private func hash() {
        var dist: Double = 0
        let list = Array(visited)

        for i in 0..<list.count {
            let x1 = list[i][0]
            let y1 = list[i][1]

            for j in i+1..<list.count {
                let x2 = list[j][0]
                let y2 = list[j][1]

                dist += sqrt(Double((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)))
            }
        }

        if res.count == 0 {
            res.insert(dist)
            return
        }

        for item in res {
            if String(item) == String(dist) { break }
            else {
                res.insert(dist)
            }
        }
    } 
}
```

## 飞地的数量（Leetcode-1020）

从四条边界开始搜索，并标记。

```swift
class Solution_1020_DFS {
    var m: Int = 0
    var n: Int = 0
    var visited: [[Bool]] = []
    
    func numEnclaves(_ grid: [[Int]]) -> Int {
        m = grid.count
        n = grid.first?.count ?? 0
        visited = Array(repeating: Array(repeating: false, count: n), count: m)
        
        var i = 0
        while i < m {
            dfs(grid, i, 0)
            dfs(grid, i, n - 1)
            i += 1
        }
        
        i = 1
        while i < n - 1 {
            dfs(grid, 0, i)
            dfs(grid, m - 1, i)
            i += 1
        }
        
        var enclaves = 0
        i = 1
        while i < m - 1 {
            var j = 1
            while j < n - 1 {
                if grid[i][j] == 1 && !visited[i][j] {
                    enclaves += 1
                }
                j += 1
            }
            i += 1
        }
        return enclaves
    }
    
    func dfs(_ grid: [[Int]], _ row: Int, _ col: Int) {
        if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == 0 || visited[row][col]) {
            return;
        }
        visited[row][col] = true;
        dfs(grid, row - 1, col);
        dfs(grid, row + 1, col);
        dfs(grid, row, col - 1);
        dfs(grid, row, col + 1);
    }
}
```

## 统计封闭岛屿的数目（Leetcode-1254）
和1020类似，不过不需要先遍历四条边，可以在正常遍历中判断边界，返回bool值:

```swift
class Solution {
    func dfs(_ grid: inout [[Int]], row: Int, colum: Int) -> Bool {
        if row < 0 || colum < 0 || row >= grid.count || colum >= grid[0].count {
            return false;
        }
        
        if grid[row][colum] == 1 {
            return true;
        }

        grid[row][colum] = 1
        
        let up = dfs(&grid,row: row-1,colum: colum)
        let down = dfs(&grid,row: row+1,colum: colum)
        let left = dfs(&grid,row: row,colum: colum-1)
        let right = dfs(&grid,row: row,colum: colum+1)
        
        return up && down && left && right;
    }
    
    func closedIsland(_ grid: [[Int]]) -> Int {
        var res = 0
        var grid = grid

        for row in 0..<grid.count {
            for colum in 0..<grid[0].count {
                if grid[row][colum] == 0 {
                    if dfs(&grid, row: row, colum: colum) {
                        res += 1
                    }
                }
            }
        }
        
        return res
    }
}
```



# 岛屿变化

## 岛屿数量II（Leetcode-305）
该题总体思路是： 使用并查集不断更新数量; 需要注意的是position去重和坐标合并顺序：

```swift
class Solution {
    func numIslands2(_ m: Int, _ n: Int, _ positions: [[Int]]) -> [Int] {
        var grid: [[Int]] = Array(repeating: Array(repeating: 0, count: n), count: m)
        let dsu = DSU(m * n)
        let directions = [[0,1], [0,-1], [1,0], [-1,0]]
        var res = [Int]()
        var count = 0
        var set = Set<[Int]>()
        
        for position in positions {
            let x = position[0]
            let y = position[1]
            
            // 去重
            if !set.contains(position) {
                set.insert(position)
                count += 1
            } else {
                res.append(count)
                continue
            }
            
            grid[x][y] = 1

            var parents = Set<Int>()
            
            for direction in directions {
                let newX = x + direction[0]
                let newY = y + direction[1]
                
                // check 4 directions if any 1 can be connected
                if newX < m && newY < n && newY >= 0 && newX >= 0 && grid[newX][newY] == 1 {
                    let index1 = x * n + y
                    let index2 = newX * n + newY

                    let pId = dsu.find(index2)
                    parents.insert(pId)
			
			  // 注意参数顺序 
                    dsu.union(index2, index1)
                }
            }
            
            // 这里是减去周围不同父节点个数，而不是值为1的个数
            count -= parents.count
            
            res.append(count)
        }
        
        return res
    }
}

final class DSU {
    var parents: [Int] = []
    var count = 0

    init(_ n: Int) {
        parents = Array(repeating: 0, count: n)
        count = n

        for i in 0..<n {
            parents[i] = i
        }
    }

    func union(_ x: Int, _ y: Int) {
        let rootX = find(x)
        let rootY = find(y)

        guard rootX != rootY else { return }

        parents[rootY] = rootX
        count -= 1
    }

    func find(_ x: Int) -> Int {
        guard x != parents[x] else { return x }

        var current = x

        while current != parents[current] {
            current = parents[current]
        }

        return current
    }
}
```



# 岛屿边缘


