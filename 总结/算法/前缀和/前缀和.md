# 前缀和






##  和为 K 的子数组(LC-560)
比较容易想到O(n^2)的方法，如果要进一步优化，则需要额外空间(字典)记录已经出现前缀和个数，利用逆向思维求解: preSum[i] - preSum[j] == k => preSum[i] - k == preSum[j]: 

```swift
class Solution {
    // tc: O(n)
    // sc: O(n)
    func subarraySum(_ nums: [Int], _ k: Int) -> Int {
        var preSum = Array(repeating: 0, count: nums.count + 1)
        var ans = 0
        var counts:[Int: Int] = [:]
        counts[0] = 1

        for i in 1...nums.count {
            preSum[i] = preSum[i-1] + nums[i-1]

            if counts[preSum[i] - k] != nil {
                ans += counts[preSum[i] - k]!
            }

            counts[preSum[i], default: 0] += 1
        }

        return ans
    }
}
```

## 和可被 K 整除的子数组(LC-974)


```swift
class Solution {
    // tc: O(n)
    // sc: O(n)
    // 同宇定理
    func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int {
        var preSum = Array(repeating: 0, count: nums.count+1)
        var res = 0
        var count: [Int:Int] = [:]

        for i in 0..<nums.count {
            preSum[i+1] = preSum[i] + nums[i]
        }

        for i in 0...nums.count {
            let mod = (preSum[i] % k + k) % k // 保证正数，余数相同
            res += count[mod, default:0] // 同余定理
            count[mod,default:0] += 1
        }

        return res
    }
}
```