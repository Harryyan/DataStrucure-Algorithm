# 前缀和

PrefixSum[i] = A[0]+A[1]+...+A[i-1]: 即前i个连续元素(连续子数组)的和。前缀和模板:

```swift
// 一维前缀和模板:
var preSum = Array(repeating: 0, count: nums.count+1)
for i in 0..<nums.count {
    preSum[i+1] = preSum[i] + nums[i]
}

//二维前缀和模板:
prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1] + src[i][j] - prefixSum[i - 1][j - 1]
for i in 0..<nums.count {
    for j in 0..<nums[i].count {
        if i == 0 && j == 0 {
            prefixSum[i][j] = nums[i][j]
        } else if i == 0 {  
            prefixSum[i][j] = prefixSum[i][j-1] + nums[i][j]
        } else if j == 0 {
            prefixSum[i][j] = prefixSum[i-1][j] + nums[i][j]
        } else {
            prefixSum[i][j] = prefixSum[i - 1][j] + prefixSum[i][j - 1]  - prefixSum[i - 1][j - 1] + nums[i][j]
        }
    }
}
```


##  和为 K 的子数组(LC-560)
比较容易想到O(n^2)的方法，如果要进一步优化，则需要额外空间(字典)记录已经出现前缀和个数，利用逆向思维求解: preSum[i] - preSum[j] == k => preSum[i] - k == preSum[j]: 

```swift
class Solution {
    // tc: O(n)
    // sc: O(n)
    func subarraySum(_ nums: [Int], _ k: Int) -> Int {
        var preSum = Array(repeating: 0, count: nums.count + 1)
        var ans = 0
        var counts:[Int: Int] = [:]
        counts[0] = 1

        for i in 1...nums.count {
            preSum[i] = preSum[i-1] + nums[i-1]

            if counts[preSum[i] - k] != nil {
                ans += counts[preSum[i] - k]!
            }

            counts[preSum[i], default: 0] += 1 
        }

        return ans
    }
}
```

## 和可被 K 整除的子数组(LC-974)
暴力超时；首先得利用同余定理: 两个余数相同的preSum之间的和一定能被k整除；针对有负数的情况，要使用(preSum[i] %k + k) % k 使得负数和正数能被分到一组，例如 -3 % 7 和 4 % 7是属于同一组.

```swift
class Solution {
    // tc: O(n)
    // sc: O(n)
    // 同余定理
    func subarraysDivByK(_ nums: [Int], _ k: Int) -> Int {
        var preSum = Array(repeating: 0, count: nums.count+1)
        var res = 0
        var count: [Int:Int] = [:]

        for i in 0..<nums.count {
            preSum[i+1] = preSum[i] + nums[i]
        }

        for i in 0...nums.count {
            let mod = (preSum[i] % k + k) % k // 保证正数，余数相同
            res += count[mod, default:0] // 同余定理
            count[mod,default:0] += 1
        }

        return res
    }
}
```