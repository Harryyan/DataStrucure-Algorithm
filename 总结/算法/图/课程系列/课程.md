# 课程系列

## 课程表I（Leetcode-207）
考点： 拓扑排序(BFS+贪心). 本题是拓扑排序经典应用场景，类似场景也有任务调度, 包依赖等.

```swift
class Solution {
    func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {
        var indegree = Counter().inDegree(prerequisites)
        let outdegree = Counter().outDegree(prerequisites)
        
        var queue: [Int] = []
        
        for i in 0..<numCourses {
            if indegree[i] == nil {
                queue.append(i)
            }
        }
        
        var coursesCanTake = queue.count
        
        if coursesCanTake == 0 {
            return false
        }
        
        while queue.count > 0 {
            let index = queue.removeLast()
            let outs = outdegree[index]
            
            if let outs = outs {
                for out in outs {
                    // 入度为0
                    if indegree[out]!.count == 1 {
                        queue.append(out)
                        coursesCanTake += 1
                    } else if indegree[out]!.count > 1 {
                    	// 更新入度表 -1
                        indegree[out]?.remove(object: index)
                    }
                }
            }
        }
        
        return coursesCanTake == numCourses
    }
}
```

Python dfs做法:

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        edges = collections.defaultdict(list)
        visited = [0] * numCourses
        result = list()
        valid = True

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            nonlocal valid
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)
                    if not valid:
                        return
                elif visited[v] == 1:
                    valid = False
                    return
            visited[u] = 2
            result.append(u)
        
        for i in range(numCourses):
            if valid and not visited[i]:
                dfs(i)
        
        return valid
```

##  课程表II（Leetcode-210）
几乎和课程表I一模一样，不同之处在于要输出某一种顺序，我们只需要使用数组记录即可:

```swift
class Solution {
    // tc: O(V*E)
    // sc: O(V*E)
    func findOrder(_ numCourses: Int, _ prerequisites: [[Int]]) -> [Int] {
        var indegree = Counter().inDegree(prerequisites)    // what courses I need to learn
        let outdegree = Counter().outDegree(prerequisites)  // what courses need me
        
        var queue: [Int] = [] 
        var result = [Int]()
        
        for i in 0..<numCourses {
            if indegree[i] == nil {
                queue.append(i)
            }
        }
        
        var coursesCanTake = queue.count
        
        if coursesCanTake == 0 {
            return []
        }
        
        // BFS
        while queue.count > 0 {
            let index = queue.removeLast()
            result.append(index)
            let outs = outdegree[index]
            
            if let outs = outs {
                for out in outs {
                    if indegree[out]!.count == 1 {
                        queue.append(out)
                        coursesCanTake += 1
                    } else if indegree[out]!.count > 1 {
                        indegree[out]?.remove(object: index)
                    }
                }
            }
        }
        
        if result.count == numCourses {
            return result
        } else {
            return []
        }
    }
}
```

## 课程表III（Leetcode-630）
贪心+堆经典应用题：策略是先选取deadline最近的，如果冲突，就选择耗时最短的:

```
class Solution {
    func scheduleCourse(_ courses: [[Int]]) -> Int {
        var courses = courses.sorted(by: { $0[1] <= $1[1] })
        var heap = Heap<[Int]>(sort: {$0[0] > $1[0]}, array: [])
        var totalTime = 0

        for course in courses {
            let duration = course[0]
            let deadline = course[1]

            if totalTime + duration <= deadline {
                totalTime += course[0]
                heap.insert(course)
            } else {
                if heap.size() > 0 {
                    let top = heap.peek()!

                    if top[0] > course[0] {
                        totalTime  = totalTime - top[0] + course[0]
                        heap.removeTop()
                        heap.insert(course)
                    }
                }
            }
        }

        return heap.size()
    }
}
```


## 课程表IV（Leetcode-1462）


## 并行课程II（Leetcode-1494）


## 并行课程III（Leetcode-2050）