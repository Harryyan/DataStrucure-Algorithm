# 最小生成树

## 定义
在一个无向且有权的图中, 存在某些边，这些边可以联通起所有顶点且无回路，并且权重之和最小。这样构成的树，就是最小生成树(Minimum Spanning Tree).

一个图可能有多个MST。

<!--![](https://res.cloudinary.com/dwpjzbyux/image/upload/v1658959919/algorithm/Graph/MST/Screen_Shot_2022-07-28_at_09.58.49_jmgimx.png)
-->
## 算法

### Prim Implementation(稠密图 - Dense graph)
该算法时间复杂度是O(V^2), 适用于稠密图. 

#### 题目(Leetcode-1584)
该题首先要构建图，一个稠密图。



### Prim-Eager Implementation (稀疏图 - Sparse graph)
该算法时间复杂度是O(ElogV), 适用于稀疏图，使用优先队列求解. 若是稠密图则为O(V^2logV), 则使用普通Prim方法

Prim-Eager算法采取贪心策略，从指定顶点开始寻找最小权值领接点。图G=<V,E>, 初始状态 S = {V0}, 把与V0连接，且边的权值最小的顶点加入S(visited list)，把扫到的边都加入优先队列；重复此过程直到结束。最后看visited，也就是S中的顶点个数和总顶点个数是否一致:

#### 题目(Leetcode-1135)
该题就是MST直接应用：选取起始点1，开始贪心选边：

```swift
    // tc: O(ElogV)
    // sc: O(V)
    func minimumCost(_ n: Int, _ connections: [[Int]]) -> Int {
        guard n > 1 else { return 0 }
        
        var pq = Heap<Vertex>(priorityFunction: { $0.cost < $1.cost })
        var seen = Set<Int>()
        var cost = 0
        var graph: [Int: [(Int, Int)]] = [:]
        
        // build graph
        for connection in connections {
            graph[connection[0], default: []].append((connection[1], connection[2]))
            graph[connection[1], default: []].append((connection[0], connection[2]))
        }
        
        pq.enqueue(Vertex(start: 1, end: 1, cost: 0))
        
        while !pq.isEmpty {
            let cur = pq.dequeue()!
            
            if !seen.contains(cur.end) {
                cost += cur.cost
                
                for (end, cost) in graph[cur.end]! {
                    pq.enqueue(Vertex(start: cur.end, end: end, cost: cost))
                }
                
                seen.insert(cur.end)
            }
        }
        
        return seen.count == n ? cost : -1
    }
    
    struct Vertex {
	    let start: Int
	    let end: Int
	    let cost: Int
}
```
**其中Heap和Vertex是自定义类型**. 类似题目还有*Leetcode 1168***


### Kruskal UF
该算法时间复杂度是O(ElogE)