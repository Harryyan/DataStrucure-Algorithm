# 二叉树总结

二叉树: 树中节点的度不大于2的有序树，它是一种最简单且最重要的树. 

## 二叉树的遍历
DFS和BFS

### 前序遍历
**递归**

```swift
func preorder(_ node: TreeNode?) {
   guard let node = node else { return }
  
   result.append(node.val)
   preorder(node.left)
   preorder(node.right)
}

```

**非递归**

```swift
func preorderStack(_ root: TreeNode?) -> [Int] {
	var res: [Int] = []
	var root_cp = root
	var queue: [TreeNode] = []
		
	while root_cp != nil || !queue.isEmpty {
	   while root_cp != nil {
	     res.append(root_cp!.val)
	     queue.append(root_cp!)
	     root_cp = root_cp?.left
	   }
	    
	   let node = queue.removeLast()
	   root_cp = node.right
	}
	    
	return res
}

```

### 中序遍历
**递归**

```swift
func inorder(_ node: TreeNode?) {
     guard let node = node else { return }
        
     inorder(node.left)
     result.append(node.val)
     inorder(node.right)
}

```
**非递归**

```swift
func inorderStack(_ root: TreeNode?) -> [Int] {
    var res: [Int] = []
    var root_cp = root
    var queue: [TreeNode] = []
    
    while root_cp != nil || !queue.isEmpty {
        while root_cp != nil {
            queue.append(root_cp!)
            root_cp = root_cp?.left
        }
        
        let node = queue.removeLast()
        res.append(node.val)
        root_cp = node.right
    }
    
    return res
}

```
### 后序遍历
**递归**

```swift
func postorder(_ node: TreeNode?) {
     guard let node = node else { return }
     
     postorder(node.left)
     postorder(node.right)
     result.append(node.val)
}

```
### BFS -- 层次遍历

```swift
func bfs(_ node: TreeNode?) {
   guard var node = node else { return }
	    
	var queue: [TreeNode] = []
	queue.append(node)
	 
	while !queue.isEmpty  {
	   let node = queue.removeLast()
	   print(node.val)
	   
	   if let left = node.left {
	      queue.append(left)
	   }
	   
	   if let right = node.right {
 		   queue.append(right)
 		}
	 }
}

```
BFS一般用来求解最短，最少问题；DFS则是求解最长，最大还有求和，求祖先问题.

## 特殊树
N叉树，Trie，BST

### N叉树遍历

**递归**

```swift
func post(_ node: Node?) {
    guard node != nil else { return }
    
    for child in node!.children {
        post(child)
    }
    
    res.append(node!.val)
}
```
**非递归**

```swift
func postUsingStack(_ node: Node?) -> [Int] {
    guard let root = node else { return [] }
    
    var stack: [Node] = [root]
    var res: [Int] = []
    
    while !stack.isEmpty {
        let node = stack.removeLast()
        
        res.append(node.val)
        
        for n in node.children {
            stack.append(n)
        }
    }
    
    return res.reversed()
}
```

### Trie
前缀树，多用于处理文件路径匹配，自动补全等。基本操作包含**插入，搜索，匹配前缀**

```swift
final class Trie {
    let root: TrieNode<Character>
    
    init() {
        root = TrieNode<Character>()    // sentinel
    }
    
    func insert(_ word: String) {
        guard !word.isEmpty else { return }
        
        var currentNode = root
        
        let characters = Array(word)
        let length = characters.count
        var index = 0
        
        while index < length {
            let character = characters[index]
            
            // if already exists
            if let child = currentNode.children[character] {
                currentNode = child
            } else {
                currentNode.addChild(character)
                currentNode = currentNode.children[character]!
            }
            
            index += 1
            
            if index == length {
                currentNode.isLeaf = true
            }
        }
    }
    
    func contains(_ word: String) -> Bool {
        guard !word.isEmpty else { return false }
        
        var currentNode = root
        
        let characters = Array(word)
        let length = characters.count
        var index = 0
        
        while index < length, let child = currentNode.children[characters[index]] {
            index += 1
            currentNode = child
        }
        
        if index == length && currentNode.isLeaf {
            return true
        } else {
            return false
        }
    }
    
    func hasPrefix(_ prefix: String) -> Bool {
        guard !prefix.isEmpty else { return false }
        
        var currentNode = root
        let characters = Array(prefix)
        let length = characters.count
        var index = 0
        
        while index < length, let child = currentNode.children[characters[index]] {
            index += 1
            currentNode = child
        }
        
        if index == length {
            return true
        } else {
            return false
        }
    }
}
```

```swift
final class TrieNode<T: Hashable> {
    var value: T?
    var isLeaf = false
    var children: [T: TrieNode] = [:]
    
    init(value: T? = nil) {
        self.value = value
    }
    
    func addChild(_ value: T) {
        guard children[value] == nil else { return }
        
        children[value] = TrieNode(value: value)
    }
}

```

### 二叉搜索树
其特征就是按照中序遍历可输出有序列表；节点数值唯一，可以通过前序和中序确认一颗二叉树; (Leetcode-105)

```swift
class Solution {
    func buildTree(_ preorder: [Int], _ inorder: [Int]) -> TreeNode? {
        return dfs(preorder: preorder, inorder: inorder, left: 0, right: preorder.count)
    }

    private func dfs(preorder: [Int], inorder: [Int], left: Int, right: Int) -> TreeNode? {
        guard preorder.count > 0 else { return nil }
        guard preorder.count > 1 else { return TreeNode(preorder[0]) }

        // 构建新的前序，中序列表
        var root = preorder[0]
        var rootPostion = inorder.firstIndex(where: {$0==root})!

        var newPreLenLeft = rootPostion
        var newPreLeft: [Int] = []
        
        if newPreLenLeft > 0 {
            newPreLeft = Array(preorder[1...newPreLenLeft])
        }
        var newPreLenRight = right-1-rootPostion
        var newPreRight:[Int] = Array(preorder[1+newPreLenLeft..<right])

        var newInLeft:[Int] = Array(inorder[left...newPreLenLeft])
        var newInRight: [Int] = []

        if rootPostion+1 < inorder.count {
            newInRight = Array(inorder[(rootPostion+1)..<right])
        }

        // 获取左右节点
        let leftNode = dfs(preorder: newPreLeft, inorder: newInLeft, left:0, right: newPreLenLeft)
        let rightNode = dfs(preorder: newPreRight, inorder: newInRight, left:0, right: newPreLenRight)

        let node = TreeNode(root)
        node.left = leftNode
        node.right = rightNode

        return node
    }
}
```
