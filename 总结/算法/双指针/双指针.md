# 双指针

遍历对象过程中，不是使用单一指针进行访问，而是使用两个相同或者相反方向指针进行扫描，达到目的.

1.  快慢指针(链表)
2. 左右端点指针(二分,反向)
3. 固定间距指针(滑窗，单调队列，单调栈)

另外，双指针也可用用在merge sort里，做合并两个数组使用.


## 验证回文串 II (LC-680)
左右端点指针向中间逼近，当字符不同时，再多加判断一次即可.

```swift
class Solution {
    // tc: O(n)
    // sc: O(1)
    func validPalindrome(_ s: String) -> Bool {
        let list = Array(s)
        var left = 0
        var right = s.count-1

        while left < right && list[left] == list[right] {
            left += 1
            right -= 1
        }
        
        if left >= right {
            return true
        }

        if isValid(list, left+1, right) || isValid(list, left, right-1) { 
            return true
        }

        return false
    }

    func isValid(_ list: [Character], _ left: Int, _ right: Int) -> Bool {
        var left = left
        var right = right

        while left < right {
            if list[left] == list[right] {
                left += 1
                right -= 1
            } else {
                return false
            }
        }

        return true
    }
}
```

## 有效单词缩写 (LC-408)
两个指针分别从头开始移动，分情况讨论：缩写指针要注意数字位数；word指针遇到数字要按照数字值跳对应个数.

```swift
class Solution {
    // tc: O(n)
    // sc: O(1)
    func validWordAbbreviation(_ word: String, _ abbr: String) -> Bool {
        var list = Array(word)
        var aList = Array(abbr)
        var i = 0
        var j = 0

        while i < list.count && j < abbr.count {
            if list[i] == aList[j] {
                i += 1
                j += 1

                continue
            }

            if String(aList[j]) == "0" {
                return false
            }

            var value = 0

            while j < aList.count && aList[j].isWholeNumber && aList[j].wholeNumberValue! >= 0 && aList[j].wholeNumberValue! <= 9 {
                let num = aList[j].wholeNumberValue!
                value = value * 10 + num

                j += 1
            }

            i += value

            if value == 0 && list[i] != aList[j] {
                return false
            }
        }

        return i == list.count && j == aList.count
    }
}
```

## 三数之和 (LC-15)
左右端点指针模板题，记住要排序和去重:

```swift
class Solution {
    // tc: O(n^2)
    // sc: O(logn)
    func threeSum(_ nums: [Int]) -> [[Int]] {
        var res = [[Int]]()
        var sorted = nums
        sorted.sort()

        for i in 0 ..< sorted.count {
            if sorted[i] > 0 {
                return res
            }
            if i > 0 && sorted[i] == sorted[i - 1] {
                continue
            }
            var left = i + 1
            var right = sorted.count - 1

            while left < right {
                let sum = sorted[i] + sorted[left] + sorted[right]
                if sum < 0 {
                    left += 1
                } else if sum > 0 {
                    right -= 1
                } else {
                    res.append([sorted[i], sorted[left], sorted[right]])
                    
                    while left < right && sorted[left] == sorted[left + 1] {
                        left += 1
                    }
                    while left < right && sorted[right] == sorted[right - 1] {
                        right -= 1
                    }
                    
                    left += 1
                    right -= 1
                }
            }
        }
        return res
    }
}
```

##  会议室 II (LC-253)
经典扫描线，类似数飞机，也可以用堆来做:

```swift
class Solution {
    // tc: O(n)
    // sc: O(n)
    func minMeetingRooms(_ intervals: [[Int]]) -> Int {
        var dict: [Int: Int] = [:]

        for interval in intervals {
            dict[interval[0], default: 0] += 1
            dict[interval[1], default: 0] -= 1
        }

        var res = 0
        var count = 0
        let list = dict.sorted(by: { $0 < $1 })

        for item in list {
            let value = item.value

            count += value
            res = max(res, count)
        }

        return res
    }
}
```

##  两个稀疏向量的点积 (LC-1570)
其实就是一个指针，因为俩数组一样长，又是求点积; 使用hashmap也可以，但是数据量大的时候，会发生collision:

```swift
class SparseVector {
    var nums: [Int] = []
    
    init(_ nums: [Int]) {
        self.nums = nums
    }

    // sc:O(n)
    // tc:O(1)
    func dotProduct(_ vec: SparseVector) -> Int {
        var value = 0
        var cursor = 0

        while cursor < nums.count {
            if vec.nums[cursor] == 0 || nums[cursor] == 0 {
                cursor += 1
                continue
            }

            value += vec.nums[cursor] * nums[cursor]
            cursor += 1
        }

        return value
    }
}
``` 

##  接雨水 (LC-42)
经典递减栈解法，也可以用DP；单调栈属于双指针一种(非固定长度的左右指针):

```swift
class Solution {
    // tc: O(n)
    // sc: O(n)
    func trap(_ height: [Int]) -> Int {
        var stack: [Int] = []
        var total = 0
        var pre = 0
        
        for i in 0..<height.count {
            while !stack.isEmpty && height[i] > height[stack.last!] {
                let last = stack.removeLast()
                pre = height[last]

                if stack.isEmpty { break }
                
                let curWidth = i - stack.last! - 1
                let relativeMinBarHeight = min(height[i], height[stack.last!])
                let curHeight = max(relativeMinBarHeight - pre, 0)

                total += curWidth * curHeight
            }
            
            stack.append(i)
        }
        
        return total
    }
}
```











