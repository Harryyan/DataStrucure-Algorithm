# 二分查找

二分查找法主要是解决在“一堆数中找出指定的数”这类问题。
而想要应用二分查找法，这“一堆数”必须有一下特征：

1.  存储在数组中
2. 有序排列

## 第一个错误版本 (Leetcode-278)


```swift
class Solution : VersionControl {
    func firstBadVersion(_ n: Int) -> Int {
        var left = 1
        var right = n

        while left < right {
            let mid = left + (right - left) / 2

            if isBadVersion(mid) {
                right = mid
            } else {
                left = mid + 1
            }
        }

        return left
    }
}
```

## 寻找两个正序数组的中位数 (Leetcode-4)

1. 双指针:分别指向两个数组第一个元素；然后谁小移动谁；需要处理边界情况，例如一个数组到头了，只能移动另一个数组.
2. 类似求第K小数，是一种特殊情况。首先针对每个数组取 k/2 个数，对比最后一个数大小，将小的数组指针加1， 之后重复该过程；如果遇到数组已经访问到最后一个节点，要特殊处理;

```swift
class Solution {
    // 双指针: tc: O(m+n)
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      var i = 0
      var j = 0
      let totalCount = (nums1.count + nums2.count)/2
      var midLeft = 0   // 中位数左边
      var midRight = 0  // 中位数右边
    
      while i+j <= totalCount {
        midLeft = midRight;

        // 谁小谁先向右移动
        if (j >= nums2.count) || (i < nums1.count && nums1[i] <= nums2[j]) {
          midRight = nums1[i]
          i+=1
        } else  {
          midRight = nums2[j]
          j+=1
        }
      }
    
      if (nums1.count + nums2.count) % 2 == 0 {
        return Double(midLeft + midRight) / 2.0
      } else {
        return Double(midRight);
      }
    }
}
```

二分： tc: O(log(m+n))

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n = nums1.length;
    int m = nums2.length;
    int left = (n + m + 1) / 2;
    int right = (n + m + 2) / 2;
    //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;  
}
    
    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 
        if (len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);
        if (len1 == 0) return nums2[start2 + k - 1];

        if (k == 1) return Math.min(nums1[start1], nums2[start2]);

        int i = start1 + Math.min(len1, k / 2) - 1;
        int j = start2 + Math.min(len2, k / 2) - 1;

        if (nums1[i] > nums2[j]) {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
        else {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }
    }
```