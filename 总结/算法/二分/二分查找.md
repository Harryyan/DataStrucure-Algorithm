# 二分查找

二分查找法主要是解决在“一堆数中找出指定的数”这类问题。
而想要应用二分查找法，这“一堆数”必须有一下特征：

1.  存储在数组中
2. 有序排列

## 第一个错误版本 (Leetcode-278)


```swift
class Solution : VersionControl {
    func firstBadVersion(_ n: Int) -> Int {
        var left = 1
        var right = n

        while left < right {
            let mid = left + (right - left) / 2

            if isBadVersion(mid) {
                right = mid
            } else {
                left = mid + 1
            }
        }

        return left
    }
}
```

## 寻找两个正序数组的中位数 (Leetcode-4)

1. 双指针:分别指向两个数组第一个元素；然后谁小移动谁；需要处理边界情况，例如一个数组到头了，只能移动另一个数组.
2. 类似求第K小数，是一种特殊情况。首先针对每个数组取 k/2 个数，对比最后一个数大小，将小的数组指针加1， 之后重复该过程；如果遇到数组已经访问到最后一个节点，要特殊处理; 这种解法需要考虑较多边界条件，例如哪个数组先访问完; 当前比较区间长度和k/2的大小.

```swift
class Solution {
    // 双指针: tc: O(m+n)
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      var i = 0
      var j = 0
      let totalCount = (nums1.count + nums2.count)/2
      var midLeft = 0   // 中位数左边
      var midRight = 0  // 中位数右边
    
      while i+j <= totalCount {
        midLeft = midRight;

        // 谁小谁先向右移动
        if (j >= nums2.count) || (i < nums1.count && nums1[i] <= nums2[j]) {
          midRight = nums1[i]
          i+=1
        } else  {
          midRight = nums2[j]
          j+=1
        }
      }
    
      if (nums1.count + nums2.count) % 2 == 0 {
        return Double(midLeft + midRight) / 2.0
      } else {
        return Double(midRight);
      }
    }
}
```

二分： tc: O(log(m+n))

```swift
class Solution {
    func findMedianSortedArrays(_ nums1: [Int], _ nums2: [Int]) -> Double {
      if (nums1.count > nums2.count) {
        return findMedianSortedArrays(nums2, nums1);
      }

      var left = 0, right = nums1.count 
      var median1 = 0.0, median2 = 0.0
      
      while left <= right {
        let i = (left + right) / 2
        let j = (nums1.count + nums2.count + 1) / 2 - i

        let nums_im1 = (i == 0 ? Int.min : nums1[i - 1])
        let nums_i = (i == nums1.count ? Int.max : nums1[i])
        let nums_jm1 = (j == 0 ? Int.min : nums2[j - 1])
        let nums_j = (j == nums2.count ? Int.max : nums2[j])

        if nums_im1 <= nums_j {
          median1 = Double(max(nums_im1, nums_jm1))
          median2 = Double(min(nums_i, nums_j))
          left = i + 1
        } else {
          right = i - 1
        }
      }
      return (nums1.count + nums2.count) % 2 == 0 ? (median1 + median2) / 2.0 : median1
    }
}
```

## 分割数组的最大值 (Leetcode-410)
该题可用动归和二分来做，以下是二分做法, 亮点在于:

1. 二分的start和end的确定
2. 贪心获取分组数目

```swift
class Solution {
    func splitArray(_ nums: [Int], _ m: Int) -> Int {
        let maxItem = nums.max()!
        let sum = nums.reduce(.zero, +)

        var left = maxItem
        var right = sum

        while left < right {
            let mid = left + (right - left) / 2
            var count = 1
            var sum = 0

		// 贪心是得到最少子数组的方式
            for i in 0..<nums.count {
                sum += nums[i]

                if sum <= mid {
                    continue
                } else {
                    sum = nums[i]
                    count += 1
                }
            }

            if count <= m {
                right = mid
            } else {
                left = mid + 1
            }
        }

        return left
    }
}
```

