# 扫描线

线性扫描算法，一般来讲使用hashmap更新起点，终点数值，最终扫描得出结果.

## 打飞机（Lintcode-391）

扫描线经典例题，记录没对start，end时飞机增减个数，最后遍历一遍求出最多飞机数。和差分类似。

```swift
/*
Definition of Interval:
class Interval {
    var start: Int
    var end: Int
    init() { start = 0; end = 0; }
    init(_ a: Int, _ b: Int) { start = a; end = b }
}
 */

/*
 @param airplanes: An interval array
 @return: Count of airplanes are in the sky.
*/
func countOfAirplanes(_ airplanes: Array<Interval>) -> Int {
    var dict: [Int: Int] = [:]

    for airplane in airplanes {
        dict[airplane.start, default: 0] += 1
        dict[airplane.end, default: 0] -= 1
    }
 
    var list = dict.sorted(by: { $0.0 < $1.0 })
    var res = 0
    var total = 0

    for (_, value) in list {
        total += value
        res = max(res, total)
    }

    return res
}
```

## 会议室I（Leetcode-252）

简单的区间判重，重点是先排序.

```swift
class Solution {
    func canAttendMeetings(_ intervals: [[Int]]) -> Bool {
        guard intervals.count > 1 else { return true }
        
        var intervals = intervals.sorted(by: {$0[0]<$1[0]})

        for i in 1..<intervals.count {
            if intervals[i][0] < intervals[i-1][1] {
                return false
            }
        }

        return true
    }
}
```

## 会议室II（Leetcode-253）

和lintcode 391数飞机一样. 该题也可以使用优先队列解答，先按照起始点排序，再将intervals入最小堆，使用结束时间排序.

```swift
class Solution {
    func minMeetingRooms(_ intervals: [[Int]]) -> Int {
        var dict: [Int: Int] = [:]

        for interval in intervals {
            dict[interval[0], default: 0] += 1
            dict[interval[1], default: 0] -= 1
        }

        var res = 0
        var count = 0
        let list = dict.sorted(by: { $0 < $1 })

        for item in list {
            let value = item.value

            count += value
            res = max(res, count)
        }

        return res
    }
}
```

## 合并区间（Leetcode-56）

现将区间按照起始点排序，然后逐个合并

```swift
class Solution {
    func merge(_ intervals: [[Int]]) -> [[Int]] {
        let intervals = intervals.sorted(by: {$0[0] < $1[0]})
        
        var merged = [[Int]]()
        merged.append(intervals[0])
        
        for i in 1..<intervals.count {
            let temp = intervals[i]
            var current = merged.removeLast()
            if temp[0] <= current[1] {
                current[1] = max(temp[1],current[1])
                merged.append(current)
            } else {
                merged.append(current)
                merged.append(temp)
            }
        }
        return merged
    }
}
```

## 插入区间（Leetcode-57）

将待插入区间append到区间数组中，然后和56题一样，按照起始点排序，再合并.

```swift
class Solution {
    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {
        var intervals = intervals
        intervals.append(newInterval)
        intervals = intervals.sorted(by: {$0[0]<$1[0]})

        var merged: [[Int]] = []

        for interval in intervals {
            if merged.isEmpty || interval[0] > merged.last![1] {
                merged.append(interval)
            } else {
                let temp = [min(merged.last![0], interval[0]), max(merged.last![1], interval[1])]
                merged.removeLast()
                merged.append(temp)
            }
        }

        return merged
    }
}
```

## 删除区间（Leetcode-1272）
迭代比较，分情况讨论： 

1. 完全不相交(两种).  
   ---                           ---
         ---      和      ---      
2. 相交：分左右两部分分别添加
    --              --             --
     ----        ----      ----    

```swift
class Solution {
    func removeInterval(_ intervals: [[Int]], _ toBeRemoved: [Int]) -> [[Int]] {
        var result: [[Int]] = []

        for interval in intervals {
            if interval[0] >= toBeRemoved[1] || interval[1] <= toBeRemoved[0] {
                result.append(interval)
            } else {
                if interval[0] < toBeRemoved[0] {
                    result.append([interval[0], toBeRemoved[0]])
                }

                if interval[1] > toBeRemoved[1] {
                    result.append([toBeRemoved[1], interval[1]])
                }
            }
        }

        return result
    }
}
```
