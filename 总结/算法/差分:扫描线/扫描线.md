# 扫描线

线性扫描算法，一般来讲使用hashmap更新起点，终点数值，最终扫描得出结果.

## 打飞机（Lintcode-391）

扫描线经典例题，记录没对start，end时飞机增减个数，最后遍历一遍求出最多飞机数。和差分类似。

```swift
/*
Definition of Interval:
class Interval {
    var start: Int
    var end: Int
    init() { start = 0; end = 0; }
    init(_ a: Int, _ b: Int) { start = a; end = b }
}
 */

/*
 @param airplanes: An interval array
 @return: Count of airplanes are in the sky.
*/
func countOfAirplanes(_ airplanes: Array<Interval>) -> Int {
    var dict: [Int: Int] = [:]

    for airplane in airplanes {
        dict[airplane.start, default: 0] += 1
        dict[airplane.end, default: 0] -= 1
    }
 
    var list = dict.sorted(by: { $0.0 < $1.0 })
    var res = 0
    var total = 0

    for (_, value) in list {
        total += value
        res = max(res, total)
    }

    return res
}
```

## 会议室I（Leetcode-252）

简单的区间判重，重点是先排序.

```swift
class Solution {
    func canAttendMeetings(_ intervals: [[Int]]) -> Bool {
        guard intervals.count > 1 else { return true }
        
        var intervals = intervals.sorted(by: {$0[0]<$1[0]})

        for i in 1..<intervals.count {
            if intervals[i][0] < intervals[i-1][1] {
                return false
            }
        }

        return true
    }
}
```

## 会议室II（Leetcode-253）

和lintcode 391数飞机一样. 该题也可以使用优先队列解答，先按照起始点排序，再将intervals入最小堆，使用结束时间排序.

```swift
class Solution {
    func minMeetingRooms(_ intervals: [[Int]]) -> Int {
        var dict: [Int: Int] = [:]

        for interval in intervals {
            dict[interval[0], default: 0] += 1
            dict[interval[1], default: 0] -= 1
        }

        var res = 0
        var count = 0
        let list = dict.sorted(by: { $0 < $1 })

        for item in list {
            let value = item.value

            count += value
            res = max(res, count)
        }

        return res
    }
}
```

## 合并区间（Leetcode-56）

现将区间按照起始点排序，然后逐个合并

```swift
class Solution {
    func merge(_ intervals: [[Int]]) -> [[Int]] {
        let intervals = intervals.sorted(by: {$0[0] < $1[0]})
        
        var merged = [[Int]]()
        merged.append(intervals[0])
        
        for i in 1..<intervals.count {
            let temp = intervals[i]
            var current = merged.removeLast()
            if temp[0] <= current[1] {
                current[1] = max(temp[1],current[1])
                merged.append(current)
            } else {
                merged.append(current)
                merged.append(temp)
            }
        }
        return merged
    }
}
```

## 插入区间（Leetcode-57）

将待插入区间append到区间数组中，然后和56题一样，按照起始点排序，再合并.

```swift
class Solution {
    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {
        var intervals = intervals
        intervals.append(newInterval)
        intervals = intervals.sorted(by: {$0[0]<$1[0]})

        var merged: [[Int]] = []

        for interval in intervals {
            if merged.isEmpty || interval[0] > merged.last![1] {
                merged.append(interval)
            } else {
                let temp = [min(merged.last![0], interval[0]), max(merged.last![1], interval[1])]
                merged.removeLast()
                merged.append(temp)
            }
        }

        return merged
    }
}
```

## 删除区间（Leetcode-1272）
迭代比较，分情况讨论： 

1.  完全不相交
2. 相交：分左右两部分分别添加

```swift
class Solution {
    func removeInterval(_ intervals: [[Int]], _ toBeRemoved: [Int]) -> [[Int]] {
        var result: [[Int]] = []

        for interval in intervals {
            if interval[0] >= toBeRemoved[1] || interval[1] <= toBeRemoved[0] {
                result.append(interval)
            } else {
                if interval[0] < toBeRemoved[0] {
                    result.append([interval[0], toBeRemoved[0]])
                }

                if interval[1] > toBeRemoved[1] {
                    result.append([toBeRemoved[1], interval[1]])
                }
            }
        }

        return result
    }
}
```

## 无重叠区间（Leetcode-435）

依旧是排序，tricky的点在于要按照结束时间(最后一个元素)排序，然后贪心求解. 
遇到这种题要先考虑怎么排序，一般就两种：按照start或者end排.

```swift
class Solution {
    func eraseOverlapIntervals(_ intervals: [[Int]]) -> Int {
        var intervals = intervals
        intervals = intervals.sorted(by: {$0[1]<$1[1]})
        
        var res = 0
        var end = Int.min

        for interval in intervals {
            if end <= interval[0] {
                end = interval[1]
            } else {
                res += 1
            }
        }

        return res
    }
}
```


## 删除被覆盖区间（Leetcode-1288）

排序。这里有个tricky的点：排序可以有4种组合: 左边递增或递减，右边递增或递减。这个题就是左边递增，右边递减；为了避免双重循环，我们可以不断维护rmax变量来做判断.

```swift
class Solution {
    func removeCoveredIntervals(_ intervals: [[Int]]) -> Int {
        guard intervals.count > 1 else { return 1 }

        // 左端递增，右端递减
        var intervals = intervals.sorted(by: {
            if $0[0] != $1[0] {
                return $0[0] < $1[0]
            } else {
                return $0[1] >= $1[1]
            }
        })

        var res = intervals.count
        var rmax = intervals[0][1]

        // tc: O(n)
        for i in 1..<intervals.count {
            // 覆盖
            if rmax >= intervals[i][1] {
                res -= 1
            } else {
                rmax = intervals[i][1]
            }
        }

        return res
    }
}
```

