# 栈总结

## 特征

1. 单调栈是栈顶元素按照单调递增性或递减性的特殊栈。
2.   **单调递增栈**确定数组中每个元素的左右两边第一个比它小的值，单调递减栈确定数组中每个元素的左右两边第一个比它大的值。
3. 设当前压入元素为a，栈顶元素为b， 栈顶元素的下一个元素为c。如果a>b，是栈顶元素弹出，则a是右边第一个大于栈顶的元素，c为左边第一个大于栈顶的元素。

### 柱状图中最大的矩形（Leetcode-84）
维护单调递增栈，遇到当前元素高度小于栈顶元素高度时，操作栈；
这道题的思路入口在于: 我们和容易想到求最大面积的暴力解法: 遍历每个元素，找到其左右两边第一个小于它的元素，然后求面积，最终找到最大的那个。这样就可以转换为使用单调栈求解某元素左右两边第一个比它小的值，从而得到如下解法:

```swift
func largestRectangleArea(_ heights: [Int]) -> Int {
   // 加哨兵，确保左右两边一定有比原始元素小的值存在
    let heights = [0] + heights + [0]
    var stack: [Int] = []
    var maxArea = 0
    
    for i in 0..<heights.count {
        while !stack.isEmpty && heights[i] < heights[stack.last!] {
            let currentHeight = heights[stack.removeLast()]
            let currentWidth = i - stack.last! - 1
            maxArea = max(currentWidth * currentHeight, maxArea)
        }
        
        stack.append(i)
    }
    
    return maxArea
}
```

### 接雨水（Leetcode-42）
同样，也是找到左右两边第一个比当前元素大的值(单调递减)，然后计算面积；不同支出在于是累加求和，而且计算过的面积不能重复计算

```swift
func trap(_ height: [Int]) -> Int {
    var stack: [Int] = []
    var total = 0
    var pre = 0
    
    for i in 0..<height.count {
        while !stack.isEmpty && height[i] > height[stack.last!] {
            let last = stack.removeLast()
            pre = height[last]

            if stack.isEmpty { break }
            
            let curWidth = i - stack.last! - 1
            let relativeMinBarHeight = min(height[i], height[stack.last!])
            let curHeight = max(relativeMinBarHeight - pre, 0)

            total += curWidth * curHeight
        }
        
        stack.append(i)
    }
    
    return total
}
```

### 每日温度 (Leetcode-739)
这题更为直白，直接告诉我们找右边第一个比它大的温度，那维护一个单调递减栈即可

```swift
func dailyTemperatures(_ temperatures: [Int]) -> [Int] {
    guard temperatures.count > 1 else { return [0] }
    
    // 单调递增栈
    // [73,74,75,71,69,72,76,73]
    var stack: [Int] = []
    var res: [Int] = Array(repeating: 0, count: temperatures.count)
    
    for i in 0..<temperatures.count {
        while !stack.isEmpty && temperatures[i] > temperatures[stack.last!] {
            let lastIndex = stack.removeLast()
            res[lastIndex] = i - lastIndex
        }
        
        stack.append(i)
    }

    return res
}
```

### 车队 (Leetcode-853)
这道题并没有类似84，42题那样明显的单调递增，递减特质；但是也给我们提供了另一种使用单调栈的思路：严格的坐标轴位置先后顺序。对于这类特质，很符合栈先进后出的特性，所以也可以作为使用单调栈的信号之一:

```swift
func carFleet(_ target: Int, _ position: [Int], _ speed: [Int]) -> Int {
    guard position.count > 1 else { return position.count  }

    var dict: [Int:Double] = [:]
    var result = 0

    for (i, p) in position.enumerated() {
        dict[p] = Double((target-p))/Double(speed[i])
    }

    var stack = dict.sorted(by: {$0.0<$1.0})

    while !stack.isEmpty {
        let car1 = stack.removeLast()
        if stack.isEmpty {
            result += 1
            break
        }

        let car2 = stack.removeLast()

        if car2.value > car1.value {
            result += 1
            stack.append(car2)
        } else {
            stack.append(car1)
        }
    }

    return result
}
```

### 车队II (Leetcode-1776)
数据已经按照position排了序，本质上还是分析如何出栈，模板代码： for loop中嵌套while循环:

```swift
func getCollisionTimes(_ cars: [[Int]]) -> [Double] {
    var res = Array(repeating: 0.00000, count: cars.count)
    var stack: [Int] = []

    for i in stride(from: res.count-1, through: 0, by: -1) {
        while !stack.isEmpty {
            print(stack)
            let s = stack.last!
            if cars[i][1] <= cars[s][1] {
                // 速度小于等于pos大的车，一定赶不上
                stack.removeLast()
            } else {
                if res[stack.last!] == -1 {
                    break
                } 

                // a,b,c三车，看a和b先遇上，还是b和c先遇上
                let distance = res[stack.last!]*Double(cars[i][1]-cars[stack.last!][1])
                if distance > Double(cars[stack.last!][0]-cars[i][0]) {
                    break
                } else {
                    // a和b先遇上，c可以被弹出
                    stack.removeLast()
                }
            }
        }

        if stack.isEmpty {
            res[i] = -1.00000
        } else {
            let p1 = cars[i][0]
            let s1 = cars[i][1]
            let p2 = cars[stack.last!][0]
            let s2 = cars[stack.last!][1]
		
		// 计算时间
            res[i] = Double(p1-p2) / Double(s2-s1)
        }

        stack.append(i)
    }

    return res
}
```

### 子数组最小乘积的最大值 (Leetcode-1856)
这道和42，84类似: 寻找每个元素左边第一个比它小的和右边第一个比它小的(和84一致)；每个元素都有可能是最小值，那么我们可以遍历每个元素，但要提前准备两个单调递增栈, 模板代码： for loop 嵌套 while:

类似问题： Leetcode-901

```swift
func maxSumMinProduct(_ nums: [Int]) -> Int {
    var nums = [0] + nums + [0]
    var preSum = [0]

    for i in nums {
        let pre = preSum.last!
        preSum.append(pre + i)
    }

    var right_first_smaller = Array(repeating: -1, count:nums.count)
    var left_first_smaller = Array(repeating: -1, count:nums.count)
    var stack: [Int] = []

    for i in 0..<nums.count {
        while stack.count>0 && nums[i]<nums[stack.last!] {
            right_first_smaller[stack.removeLast()] = i
        }
        stack.append(i)
    }

    stack = []

    for j in stride(from: nums.count-1, through: 0, by: -1) {
        while stack.count>0 && nums[j]<nums[stack.last!] {
            left_first_smaller[stack.removeLast()] = j
        }
        stack.append(j)
    }

    var res = 0
    for i in 1..<nums.count-1 {
        let left = left_first_smaller[i]
        let right = right_first_smaller[i]
        res = max(res, nums[i]*(preSum[right]-preSum[left+1]))
    }

    return res % (1000000007)
}
```

###  最大宽度坡 (Leetcode-962)
这题只用了单调递减栈，然后从右遍历。如果是求最窄坡，则又变成求右侧第一个大于等于该元素的值。

```swift
func maxWidthRamp(_ nums: [Int]) -> Int {
    var stack: [Int] = []
    stack.append(0)
    var result = 0

    for i in 1..<nums.count {
        // 单调递减栈
        if nums[i] <= nums[stack.last!] {
            stack.append(i)
        }
    }

    for i in stride(from: nums.count-1, through: 0, by: -1) {
        while stack.count > 0 && nums[i] >= nums[stack.last!] {
            result = max(result, i - stack.last!)
            stack.removeLast()
        }
    }

    return result
}
```

###  下一个最大元素I, II (Leetcode-496, 503)
类似84， 42题，维护单调递减栈，不过这题需要利用字典记录下值，最后和num1匹配; 至于503题，则是double下数组大小即可:

```swift
func nextGreaterElement(_ nums1: [Int], _ nums2: [Int]) -> [Int] {
    var stack: [Int] = []
    var dict: [Int:Int] = [:]
    
    for i in stride(from: nums2.count-1, through: 0, by: -1) {
        while stack.count > 0, let last = stack.last, last <= nums2[i] {
            _ = stack.popLast()
        }
        
        if stack.count > 0, let last = stack.last {
            dict[nums2[i]] = last
        }
        
        stack.append(nums2[i])
    }
    
    let result: [Int] = nums1.map {
        if let value = dict[$0] {
            return value
        } else {
            return -1
        }
    }
    
    return result
}
```

```swift
func nextGreaterElements(_ nums: [Int]) -> [Int] {
    let count = nums.count
    var stack: [Int] = []
    var result: [Int] = Array(repeating: -1, count: count)
    
    for i in 0..<count*2 {
        while stack.count > 0 && nums[stack.last!] < nums[i % count] {
            result[stack.popLast()!] = nums[i % count]
        }
        
        stack.append(i % count)
    }
    
    return result
}
```

## 表达式问题

### 基本计算器 (Leetcode-227)
需要注意的点: 数字不是1个digit，要循环计算出正确数字；四则运算优先级.

```swift
func doOperation(_ stack: inout [Int], _ number: Int, _ operand: Character) {
    switch operand {
        case "+": stack.append(number)
        case "-": stack.append(-number)
        case "*": stack.append(stack.removeLast() * number)
        case "/": stack.append(stack.removeLast() / number)
        default: break
    }
}
    
func calculate(_ s: String) -> Int {
    let exp = Array(s.replacingOccurrences(of: " ", with: ""))
    var number = 0
    var operand = Character("+")
    var stack = [Int]()
    
    for char in exp {
        if char.isNumber {
            number = number * 10 + Int(String(char))!
        } else {
            doOperation(&stack, number, operand)
            operand = char
            number = 0
        }
    }
    
    doOperation(&stack, number, operand)
    return stack.reduce(0, +)
}
```

### 字符串解码 (Leetcode-394)

需要注意的点: 数字的计算；可以从前到后append字符串，不必遇到了‘]’再回溯

```swift
func decodeString(_ s: String) -> String {
    var stack = [(Int, String)]()
    var res = ""
    var muti = 0
    
    for c in s {
        if c == "[" {
            stack.append((muti, res))
            muti = 0
            res = ""
        } else if c == "]" {
            if let (curMutil, lastRes) = stack.popLast() {
                res = lastRes + String(repeating: res, count: curMutil)
            }
        } else if c.isWholeNumber {
            muti = muti * 10 + c.wholeNumberValue!
        } else {
            res.append(c)
        }
    }
    return res
}
```
