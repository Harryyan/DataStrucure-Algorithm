# 链表总结

链表分为单向链表，双向链表，带环链表.

## 考察点

### 反转链表

定义current，pre变量存储节点.

```swift
func reverseList(_ head: ListNode?) -> ListNode? {
    guard let node = head else { return nil }

    var cur: ListNode? = node
    var pre: ListNode? = nil

    while cur != nil {
        let next = cur?.next
        cur?.next = pre
        pre = cur
        cur = next
    }

    return pre
}
```

### 求第某个节点

### 快慢指针求中间节点

```swift
func middleNode(_ head: ListNode?) -> ListNode? {
    guard let node = head else  { return nil }
    guard let next = head?.next else { return head }

    var slow = head
    var fast = head

    while slow != nil && fast?.next != nil {
        slow = slow!.next
        fast = fast?.next!.next
    }

    return slow
}
```

### 求倒数第K个节点

```swift
func getKthNodeBackforward(_ node: ListNode?, _ k: Int) -> ListNode? {
    guard let node = node else { return nil }
    
    var p1: ListNode? = node
    var p2: ListNode? = node
    
    var i = 0
    
    while p1?.next != nil && i < k {
        p1 = p1?.next
        i += 1
    }
    
    if p1 == nil {
        return nil
    }
    
    while p1?.next != nil {
        p1 = p1?.next
        p2 = p2?.next
    }
    
    return p2
}
```

### 链表相交

```swift
func getIntersectionNode(_ headA: ListNode?, _ headB: ListNode?) -> ListNode? {
    var a = headA
    var b = headB

    while a !== b {
        a = a != nil ? a?.next : headB
        b = b != nil ? b?.next : headA
    }

    return a
}
```


### 带环链表

检测环，找环入口. 检测环也是快慢指针，当指针相遇时，不为null，则存在环；否则无环；

```swift
func detectCycle(_ head: ListNode?) -> ListNode? {
    guard let head = head else { return nil }

    if head.next == nil {
        return nil
    }

    var slow: ListNode? = head
    var fast: ListNode? = head

    while slow != nil && fast?.next != nil {
        slow = slow?.next
        fast = fast?.next?.next

	  // 环内相遇
        if slow === fast {
            break
        }
    }

    // 快指针从头走
    fast = head
    
    // 继续走直到相遇即是入口
    while slow !== fast {
        slow = slow?.next
        fast = fast?.next
    }
    
    return slow
}
```

### 链表相加 (两数相加)

```swift
func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {
    var head1 = l1
    var head2 = l2
    var add = 0
    var dummy: ListNode = ListNode(-1)
    var cur = dummy

    while head1 != nil || head2 != nil {
        let a = head1?.val ?? 0
        let b = head2?.val ?? 0
        var newValue = a+b+add

        if newValue > 9 {
            newValue = newValue % 10
            add = 1
        } else {
            add = 0
        }

        var temp = ListNode(newValue)

        cur.next = temp
        cur = temp

        head1 = head1?.next
        head2 = head2?.next
    }

    if add == 1 {
        var temp = ListNode(1)
        cur.next = temp
    }

    return dummy.next
}
```

### 链表合并 (堆 + 分治)
可以使用优先队列，遍历所有节点，最后pop堆顶；
也可以使用分治，两两合并;

```swift
func mergeKLists(_ lists: [ListNode?]) -> ListNode? {
    var items: [Int] = []

    for list in lists {
        var node = list

        while node != nil {
            items.append(node!.val)
            node = node!.next
        }
    }

    var heap = Heap<Int>(<=, items)
    var dummy = ListNode(-1)
    var cur = dummy

    for i in items {
        let a = heap.removeTop()
        let node = ListNode(a!)
        cur.next = node
        cur = node
    }

    return dummy.next
}
```
**Heap**是自定义实现.

分治算法:

```swift
func mergeTwoLists(_ node1: ListNode?, _ node2: ListNode?) -> ListNode? {
    guard let _ = node1 else { return node2 }
    guard let _ = node2 else { return node1 }
    
    if node1!.val < node2!.val {
        node1!.next = mergeTwoLists(node1?.next, node2)
        return node1
    } else {
        node2!.next = mergeTwoLists(node2?.next, node1)
        return node2
    }
}
```


