# 设计题目

设计题目综合考察数据结构，算法和代码质量.

## 146. LRU Cache
比较常见的设计题，使用哈希表和双向链表降低时间复杂度:

```swift
final class LRUCache {
    private(set) var capacity: Int = 0
    private(set) var dictionary = [Int: Node]()
    var first: Node!
    var last: Node!
    
    init(_ capacity: Int) {
        self.capacity = capacity
        dictionary = [Int:Node]()
        
        first = Node()
        last = Node()
        
        first.next = last
        last.prev = first
    }
    
    func get(_ key: Int) -> Int {
        guard let node = dictionary[key] else {
            return -1
        }
        
        removeNode(node)
        addAtFirst(node)
        
        return node.val
    }
    
    func put(_ key: Int, _ value: Int) {
        let node = dictionary[key]
        if node != nil {
            //! 更新 key
            node!.val = value
            removeNode(node!)
            addAtFirst(node!)
            
        } else {
            if dictionary.keys.count == capacity {
                //! 淘汰最近最少使用
                let prevNode = dictionary.removeValue(forKey: last.prev!.key)!
                removeNode(prevNode)
            }
            
            let newNode = Node(key, value)
            dictionary[key] = newNode
            addAtFirst(newNode)
        }
    }
    
    //! 双向链表 -> 删除 自身
    private func removeNode(_ node: Node) {
        node.next!.prev = node.prev
        node.prev!.next = node.next
    }
    
    //! 双向链表 -> 插入节点到头节点后面
    private func addAtFirst(_ node: Node) {
        node.next = first.next
        first.next!.prev = node
        
        first.next = node
        node.prev = first
    }
}

class Node {
    var key:Int = 0
    var val: Int = 0
    
    var prev: Node?
    var next: Node?
    
    var left: Node?
    var right: Node?
    
    init(_ key: Int = 0, _ value: Int = 0) {
        self.key = key
        self.val = value
    }
}
```

## 706. Design HashMap

考察散列表设计，如何设计散列函数，如何解决冲突，至于装载因子，则不在考察范围。散列函数一般可以用除数余留法；解决冲突则常用拉链法(定长拉链和不定长拉链).

```swift
class MyHashMap {
    var dict: [[Int]] = []

    init() {
        dict = Array(repeating: Array(repeating: -1, count: 1000), count: 1001)
    }
    
    func put(_ key: Int, _ value: Int) {
        let row = key / 1000 // bucket
        let col = key % 1000 // position

        dict[row][col] = value
    }
    
    func get(_ key: Int) -> Int {
        let row = key / 1000
        let col = key % 1000

        return dict[row][col]
    }
    
    func remove(_ key: Int) {
        let row = key / 1000
        let col = key % 1000

        dict[row][col] = -1
    }
}
```

## 355. Design Twitter
考察哈希表和链表应用：

```swift
class Twitter {
    var news: ListNode?
    var userMap: [Int: Set<Int>] = [:]

    init() {}
    
    // tc: O(1)
    func postTweet(_ userId: Int, _ tweetId: Int) {
        let node = ListNode(userId, tweetId, news)
        news = node
        
        if userMap[userId] == nil {
            var set = Set<Int>()
            set.insert(userId)
            userMap.updateValue(set, forKey: userId)
        }
    }
    
    // tc: O(n)
    func getNewsFeed(_ userId: Int) -> [Int] {
        var p = news
        var k = 10
        var result: [Int] = []

        guard let followers = userMap[userId] else {
            return result
        }
        
        while p != nil, k > 0 {
            if followers.contains(p!.userId) {
                result.append(p!.tweetId)
                k -= 1
            }
            p = p?.next
        }
        
        return result
    }
    
    func follow(_ followerId: Int, _ followeeId: Int) {
        if userMap[followerId] == nil {
            var set = Set<Int>()
            set.insert(followerId)
            userMap.updateValue(set, forKey: followerId)
        }

        userMap[followerId]?.insert(followeeId)
    }
    
    func unfollow(_ followerId: Int, _ followeeId: Int) {
        userMap[followerId]?.remove(followeeId)
    }
}

public class ListNode {
    public var userId: Int
    public var tweetId: Int
    public var next: ListNode?
    
    internal init(_ userId: Int, _ tweetId: Int, _ next: ListNode? = nil) {
        self.userId = userId
        self.tweetId = tweetId
        self.next = next
    }
}
```

## 304. Range Sum Query 2D - Immutable
训练二维前缀和模板

```swift
class NumMatrix {
    var preSum: [[Int]] = []

    init(_ matrix: [[Int]]) {
        var m = matrix.count
        var n = matrix[0].count
        
        preSum = Array(repeating:Array(repeating:0, count:n + 1), count:m + 1)

        for i in 0..<m {
            for j in 0..<n {
                preSum[i + 1][j + 1] = preSum[i][j + 1] + preSum[i + 1][j] - preSum[i][j] + matrix[i][j]
            }
        }
    }
    
    func sumRegion(_ row1: Int, _ col1: Int, _ row2: Int, _ col2: Int) -> Int {
        return preSum[row2 + 1][col2 + 1] - preSum[row1][col2 + 1] - preSum[row2 + 1][col1] + preSum[row1][col1]
    }
}
```